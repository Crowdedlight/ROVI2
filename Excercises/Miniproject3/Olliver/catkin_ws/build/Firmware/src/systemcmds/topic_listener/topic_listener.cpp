

/****************************************************************************
 *
 *   Copyright (c) 2015 PX4 Development Team. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name PX4 nor the names of its contributors may be
 *    used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 ****************************************************************************/

/**
 * @file topic_listener.cpp
 *
 * Autogenerated by Tools/generate_listener.py
 *
 * Tool for listening to topics when running flight stack on linux.
 */

#include <drivers/drv_hrt.h>
#include <px4_middleware.h>
#include <px4_app.h>
#include <px4_config.h>
#include <uORB/uORB.h>
#include <string.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>

#ifndef PRIu64
#define PRIu64 "llu"
#endif

#ifndef PRId64
#define PRId64 "lld"
#endif


#include <uORB/topics/sensor_baro.h>
#include <uORB/topics/mission.h>
#include <uORB/topics/transponder_report.h>
#include <uORB/topics/actuator_controls.h>
#include <uORB/topics/rate_ctrl_status.h>
#include <uORB/topics/power_button_state.h>
#include <uORB/topics/mount_orientation.h>
#include <uORB/topics/subsystem_info.h>
#include <uORB/topics/uavcan_parameter_value.h>
#include <uORB/topics/log_message.h>
#include <uORB/topics/actuator_outputs.h>
#include <uORB/topics/esc_report.h>
#include <uORB/topics/test_motor.h>
#include <uORB/topics/esc_status.h>
#include <uORB/topics/differential_pressure.h>
#include <uORB/topics/adc_report.h>
#include <uORB/topics/vehicle_attitude.h>
#include <uORB/topics/cpuload.h>
#include <uORB/topics/rc_channels.h>
#include <uORB/topics/sensor_bias.h>
#include <uORB/topics/vehicle_status_flags.h>
#include <uORB/topics/vehicle_command.h>
#include <uORB/topics/camera_capture.h>
#include <uORB/topics/obstacle_distance.h>
#include <uORB/topics/debug_key_value.h>
#include <uORB/topics/airspeed.h>
#include <uORB/topics/safety.h>
#include <uORB/topics/camera_trigger.h>
#include <uORB/topics/landing_target_pose.h>
#include <uORB/topics/vehicle_attitude_setpoint.h>
#include <uORB/topics/telemetry_status.h>
#include <uORB/topics/multirotor_motor_limits.h>
#include <uORB/topics/sensor_accel.h>
#include <uORB/topics/debug_value.h>
#include <uORB/topics/vehicle_global_position.h>
#include <uORB/topics/servorail_status.h>
#include <uORB/topics/actuator_armed.h>
#include <uORB/topics/ekf2_timestamps.h>
#include <uORB/topics/position_setpoint_triplet.h>
#include <uORB/topics/estimator_status.h>
#include <uORB/topics/vehicle_control_mode.h>
#include <uORB/topics/landing_target_innovations.h>
#include <uORB/topics/task_stack_info.h>
#include <uORB/topics/vehicle_status.h>
#include <uORB/topics/system_power.h>
#include <uORB/topics/sensor_combined.h>
#include <uORB/topics/vehicle_rates_setpoint.h>
#include <uORB/topics/wind_estimate.h>
#include <uORB/topics/tecs_status.h>
#include <uORB/topics/sensor_correction.h>
#include <uORB/topics/optical_flow.h>
#include <uORB/topics/pwm_input.h>
#include <uORB/topics/position_setpoint.h>
#include <uORB/topics/irlock_report.h>
#include <uORB/topics/collision_report.h>
#include <uORB/topics/led_control.h>
#include <uORB/topics/ekf2_innovations.h>
#include <uORB/topics/uavcan_parameter_request.h>
#include <uORB/topics/vehicle_gps_position.h>
#include <uORB/topics/rc_parameter_map.h>
#include <uORB/topics/parameter_update.h>
#include <uORB/topics/geofence_result.h>
#include <uORB/topics/vehicle_air_data.h>
#include <uORB/topics/sensor_selection.h>
#include <uORB/topics/att_pos_mocap.h>
#include <uORB/topics/battery_status.h>
#include <uORB/topics/vehicle_magnetometer.h>
#include <uORB/topics/vehicle_land_detected.h>
#include <uORB/topics/time_offset.h>
#include <uORB/topics/mission_result.h>
#include <uORB/topics/satellite_info.h>
#include <uORB/topics/vtol_vehicle_status.h>
#include <uORB/topics/vehicle_local_position.h>
#include <uORB/topics/manual_control_setpoint.h>
#include <uORB/topics/vehicle_local_position_setpoint.h>
#include <uORB/topics/home_position.h>
#include <uORB/topics/fw_pos_ctrl_status.h>
#include <uORB/topics/sensor_preflight.h>
#include <uORB/topics/tune_control.h>
#include <uORB/topics/sensor_gyro.h>
#include <uORB/topics/commander_state.h>
#include <uORB/topics/vehicle_command_ack.h>
#include <uORB/topics/debug_vect.h>
#include <uORB/topics/distance_sensor.h>
#include <uORB/topics/offboard_control_mode.h>
#include <uORB/topics/mavlink_log.h>
#include <uORB/topics/actuator_direct.h>
#include <uORB/topics/input_rc.h>
#include <uORB/topics/follow_target.h>
#include <uORB/topics/vehicle_roi.h>
#include <uORB/topics/sensor_mag.h>

extern "C" __EXPORT int listener_main(int argc, char *argv[]);

static bool check_timeout(const hrt_abstime& time) {
    if (hrt_elapsed_time(&time) > 2*1000*1000) {
		printf("Waited for 2 seconds without a message. Giving up.\n");
        return true;
    }
    return false;
}

void listen_distance_sensor(unsigned num_msgs, unsigned topic_instance);
void listen_ekf2_timestamps(unsigned num_msgs, unsigned topic_instance);
void listen_esc_report(unsigned num_msgs, unsigned topic_instance);
void listen_sensor_preflight(unsigned num_msgs, unsigned topic_instance);
void listen_sensor_baro(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_control_mode(unsigned num_msgs, unsigned topic_instance);
void listen_tune_control(unsigned num_msgs, unsigned topic_instance);
void listen_manual_control_setpoint(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_air_data(unsigned num_msgs, unsigned topic_instance);
void listen_telemetry_status(unsigned num_msgs, unsigned topic_instance);
void listen_actuator_outputs(unsigned num_msgs, unsigned topic_instance);
void listen_task_stack_info(unsigned num_msgs, unsigned topic_instance);
void listen_collision_report(unsigned num_msgs, unsigned topic_instance);
void listen_esc_status(unsigned num_msgs, unsigned topic_instance);
void listen_sensor_accel(unsigned num_msgs, unsigned topic_instance);
void listen_cpuload(unsigned num_msgs, unsigned topic_instance);
void listen_transponder_report(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_rates_setpoint(unsigned num_msgs, unsigned topic_instance);
void listen_mc_virtual_rates_setpoint(unsigned num_msgs, unsigned topic_instance);
void listen_fw_virtual_rates_setpoint(unsigned num_msgs, unsigned topic_instance);
void listen_sensor_bias(unsigned num_msgs, unsigned topic_instance);
void listen_debug_vect(unsigned num_msgs, unsigned topic_instance);
void listen_vtol_vehicle_status(unsigned num_msgs, unsigned topic_instance);
void listen_test_motor(unsigned num_msgs, unsigned topic_instance);
void listen_subsystem_info(unsigned num_msgs, unsigned topic_instance);
void listen_wind_estimate(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_magnetometer(unsigned num_msgs, unsigned topic_instance);
void listen_follow_target(unsigned num_msgs, unsigned topic_instance);
void listen_airspeed(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_roi(unsigned num_msgs, unsigned topic_instance);
void listen_pwm_input(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_command_ack(unsigned num_msgs, unsigned topic_instance);
void listen_differential_pressure(unsigned num_msgs, unsigned topic_instance);
void listen_geofence_result(unsigned num_msgs, unsigned topic_instance);
void listen_ekf2_innovations(unsigned num_msgs, unsigned topic_instance);
void listen_fw_pos_ctrl_status(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_global_position(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_global_position_groundtruth(unsigned num_msgs, unsigned topic_instance);
void listen_optical_flow(unsigned num_msgs, unsigned topic_instance);
void listen_parameter_update(unsigned num_msgs, unsigned topic_instance);
void listen_position_setpoint_triplet(unsigned num_msgs, unsigned topic_instance);
void listen_actuator_controls(unsigned num_msgs, unsigned topic_instance);
void listen_actuator_controls_0(unsigned num_msgs, unsigned topic_instance);
void listen_actuator_controls_1(unsigned num_msgs, unsigned topic_instance);
void listen_actuator_controls_2(unsigned num_msgs, unsigned topic_instance);
void listen_actuator_controls_3(unsigned num_msgs, unsigned topic_instance);
void listen_actuator_controls_virtual_fw(unsigned num_msgs, unsigned topic_instance);
void listen_actuator_controls_virtual_mc(unsigned num_msgs, unsigned topic_instance);
void listen_position_setpoint(unsigned num_msgs, unsigned topic_instance);
void listen_actuator_direct(unsigned num_msgs, unsigned topic_instance);
void listen_home_position(unsigned num_msgs, unsigned topic_instance);
void listen_tecs_status(unsigned num_msgs, unsigned topic_instance);
void listen_debug_key_value(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_land_detected(unsigned num_msgs, unsigned topic_instance);
void listen_mount_orientation(unsigned num_msgs, unsigned topic_instance);
void listen_mavlink_log(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_status(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_attitude(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_attitude_groundtruth(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_vision_attitude(unsigned num_msgs, unsigned topic_instance);
void listen_mission_result(unsigned num_msgs, unsigned topic_instance);
void listen_battery_status(unsigned num_msgs, unsigned topic_instance);
void listen_camera_trigger(unsigned num_msgs, unsigned topic_instance);
void listen_rc_parameter_map(unsigned num_msgs, unsigned topic_instance);
void listen_satellite_info(unsigned num_msgs, unsigned topic_instance);
void listen_landing_target_innovations(unsigned num_msgs, unsigned topic_instance);
void listen_landing_target_pose(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_local_position_setpoint(unsigned num_msgs, unsigned topic_instance);
void listen_commander_state(unsigned num_msgs, unsigned topic_instance);
void listen_sensor_mag(unsigned num_msgs, unsigned topic_instance);
void listen_rc_channels(unsigned num_msgs, unsigned topic_instance);
void listen_att_pos_mocap(unsigned num_msgs, unsigned topic_instance);
void listen_sensor_combined(unsigned num_msgs, unsigned topic_instance);
void listen_camera_capture(unsigned num_msgs, unsigned topic_instance);
void listen_estimator_status(unsigned num_msgs, unsigned topic_instance);
void listen_uavcan_parameter_value(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_command(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_status_flags(unsigned num_msgs, unsigned topic_instance);
void listen_led_control(unsigned num_msgs, unsigned topic_instance);
void listen_time_offset(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_attitude_setpoint(unsigned num_msgs, unsigned topic_instance);
void listen_mc_virtual_attitude_setpoint(unsigned num_msgs, unsigned topic_instance);
void listen_fw_virtual_attitude_setpoint(unsigned num_msgs, unsigned topic_instance);
void listen_multirotor_motor_limits(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_local_position(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_local_position_groundtruth(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_vision_position(unsigned num_msgs, unsigned topic_instance);
void listen_servorail_status(unsigned num_msgs, unsigned topic_instance);
void listen_actuator_armed(unsigned num_msgs, unsigned topic_instance);
void listen_sensor_gyro(unsigned num_msgs, unsigned topic_instance);
void listen_irlock_report(unsigned num_msgs, unsigned topic_instance);
void listen_vehicle_gps_position(unsigned num_msgs, unsigned topic_instance);
void listen_offboard_control_mode(unsigned num_msgs, unsigned topic_instance);
void listen_rate_ctrl_status(unsigned num_msgs, unsigned topic_instance);
void listen_safety(unsigned num_msgs, unsigned topic_instance);
void listen_sensor_selection(unsigned num_msgs, unsigned topic_instance);
void listen_log_message(unsigned num_msgs, unsigned topic_instance);
void listen_power_button_state(unsigned num_msgs, unsigned topic_instance);
void listen_obstacle_distance(unsigned num_msgs, unsigned topic_instance);
void listen_system_power(unsigned num_msgs, unsigned topic_instance);
void listen_input_rc(unsigned num_msgs, unsigned topic_instance);
void listen_mission(unsigned num_msgs, unsigned topic_instance);
void listen_uavcan_parameter_request(unsigned num_msgs, unsigned topic_instance);
void listen_debug_value(unsigned num_msgs, unsigned topic_instance);
void listen_adc_report(unsigned num_msgs, unsigned topic_instance);
void listen_sensor_correction(unsigned num_msgs, unsigned topic_instance);


int listener_main(int argc, char *argv[]) {
	if(argc < 2) {
		printf("need at least two arguments: topic name. [optional number of messages to print] [optional instance]\n");
		return 1;
	}

	unsigned num_msgs = (argc > 2) ? atoi(argv[2]) : 1;
	unsigned topic_instance = (argc > 3) ? atoi(argv[3]) : 0;

	if (strncmp(argv[1],"distance_sensor",50) == 0) {
		listen_distance_sensor(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"ekf2_timestamps",50) == 0) {
		listen_ekf2_timestamps(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"esc_report",50) == 0) {
		listen_esc_report(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"sensor_preflight",50) == 0) {
		listen_sensor_preflight(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"sensor_baro",50) == 0) {
		listen_sensor_baro(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_control_mode",50) == 0) {
		listen_vehicle_control_mode(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"tune_control",50) == 0) {
		listen_tune_control(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"manual_control_setpoint",50) == 0) {
		listen_manual_control_setpoint(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_air_data",50) == 0) {
		listen_vehicle_air_data(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"telemetry_status",50) == 0) {
		listen_telemetry_status(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"actuator_outputs",50) == 0) {
		listen_actuator_outputs(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"task_stack_info",50) == 0) {
		listen_task_stack_info(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"collision_report",50) == 0) {
		listen_collision_report(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"esc_status",50) == 0) {
		listen_esc_status(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"sensor_accel",50) == 0) {
		listen_sensor_accel(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"cpuload",50) == 0) {
		listen_cpuload(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"transponder_report",50) == 0) {
		listen_transponder_report(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_rates_setpoint",50) == 0) {
		listen_vehicle_rates_setpoint(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"mc_virtual_rates_setpoint",50) == 0) {
		listen_mc_virtual_rates_setpoint(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"fw_virtual_rates_setpoint",50) == 0) {
		listen_fw_virtual_rates_setpoint(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"sensor_bias",50) == 0) {
		listen_sensor_bias(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"debug_vect",50) == 0) {
		listen_debug_vect(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vtol_vehicle_status",50) == 0) {
		listen_vtol_vehicle_status(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"test_motor",50) == 0) {
		listen_test_motor(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"subsystem_info",50) == 0) {
		listen_subsystem_info(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"wind_estimate",50) == 0) {
		listen_wind_estimate(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_magnetometer",50) == 0) {
		listen_vehicle_magnetometer(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"follow_target",50) == 0) {
		listen_follow_target(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"airspeed",50) == 0) {
		listen_airspeed(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_roi",50) == 0) {
		listen_vehicle_roi(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"pwm_input",50) == 0) {
		listen_pwm_input(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_command_ack",50) == 0) {
		listen_vehicle_command_ack(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"differential_pressure",50) == 0) {
		listen_differential_pressure(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"geofence_result",50) == 0) {
		listen_geofence_result(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"ekf2_innovations",50) == 0) {
		listen_ekf2_innovations(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"fw_pos_ctrl_status",50) == 0) {
		listen_fw_pos_ctrl_status(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_global_position",50) == 0) {
		listen_vehicle_global_position(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_global_position_groundtruth",50) == 0) {
		listen_vehicle_global_position_groundtruth(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"optical_flow",50) == 0) {
		listen_optical_flow(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"parameter_update",50) == 0) {
		listen_parameter_update(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"position_setpoint_triplet",50) == 0) {
		listen_position_setpoint_triplet(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"actuator_controls",50) == 0) {
		listen_actuator_controls(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"actuator_controls_0",50) == 0) {
		listen_actuator_controls_0(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"actuator_controls_1",50) == 0) {
		listen_actuator_controls_1(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"actuator_controls_2",50) == 0) {
		listen_actuator_controls_2(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"actuator_controls_3",50) == 0) {
		listen_actuator_controls_3(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"actuator_controls_virtual_fw",50) == 0) {
		listen_actuator_controls_virtual_fw(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"actuator_controls_virtual_mc",50) == 0) {
		listen_actuator_controls_virtual_mc(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"position_setpoint",50) == 0) {
		listen_position_setpoint(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"actuator_direct",50) == 0) {
		listen_actuator_direct(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"home_position",50) == 0) {
		listen_home_position(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"tecs_status",50) == 0) {
		listen_tecs_status(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"debug_key_value",50) == 0) {
		listen_debug_key_value(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_land_detected",50) == 0) {
		listen_vehicle_land_detected(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"mount_orientation",50) == 0) {
		listen_mount_orientation(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"mavlink_log",50) == 0) {
		listen_mavlink_log(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_status",50) == 0) {
		listen_vehicle_status(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_attitude",50) == 0) {
		listen_vehicle_attitude(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_attitude_groundtruth",50) == 0) {
		listen_vehicle_attitude_groundtruth(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_vision_attitude",50) == 0) {
		listen_vehicle_vision_attitude(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"mission_result",50) == 0) {
		listen_mission_result(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"battery_status",50) == 0) {
		listen_battery_status(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"camera_trigger",50) == 0) {
		listen_camera_trigger(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"rc_parameter_map",50) == 0) {
		listen_rc_parameter_map(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"satellite_info",50) == 0) {
		listen_satellite_info(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"landing_target_innovations",50) == 0) {
		listen_landing_target_innovations(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"landing_target_pose",50) == 0) {
		listen_landing_target_pose(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_local_position_setpoint",50) == 0) {
		listen_vehicle_local_position_setpoint(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"commander_state",50) == 0) {
		listen_commander_state(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"sensor_mag",50) == 0) {
		listen_sensor_mag(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"rc_channels",50) == 0) {
		listen_rc_channels(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"att_pos_mocap",50) == 0) {
		listen_att_pos_mocap(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"sensor_combined",50) == 0) {
		listen_sensor_combined(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"camera_capture",50) == 0) {
		listen_camera_capture(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"estimator_status",50) == 0) {
		listen_estimator_status(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"uavcan_parameter_value",50) == 0) {
		listen_uavcan_parameter_value(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_command",50) == 0) {
		listen_vehicle_command(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_status_flags",50) == 0) {
		listen_vehicle_status_flags(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"led_control",50) == 0) {
		listen_led_control(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"time_offset",50) == 0) {
		listen_time_offset(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_attitude_setpoint",50) == 0) {
		listen_vehicle_attitude_setpoint(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"mc_virtual_attitude_setpoint",50) == 0) {
		listen_mc_virtual_attitude_setpoint(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"fw_virtual_attitude_setpoint",50) == 0) {
		listen_fw_virtual_attitude_setpoint(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"multirotor_motor_limits",50) == 0) {
		listen_multirotor_motor_limits(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_local_position",50) == 0) {
		listen_vehicle_local_position(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_local_position_groundtruth",50) == 0) {
		listen_vehicle_local_position_groundtruth(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_vision_position",50) == 0) {
		listen_vehicle_vision_position(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"servorail_status",50) == 0) {
		listen_servorail_status(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"actuator_armed",50) == 0) {
		listen_actuator_armed(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"sensor_gyro",50) == 0) {
		listen_sensor_gyro(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"irlock_report",50) == 0) {
		listen_irlock_report(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"vehicle_gps_position",50) == 0) {
		listen_vehicle_gps_position(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"offboard_control_mode",50) == 0) {
		listen_offboard_control_mode(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"rate_ctrl_status",50) == 0) {
		listen_rate_ctrl_status(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"safety",50) == 0) {
		listen_safety(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"sensor_selection",50) == 0) {
		listen_sensor_selection(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"log_message",50) == 0) {
		listen_log_message(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"power_button_state",50) == 0) {
		listen_power_button_state(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"obstacle_distance",50) == 0) {
		listen_obstacle_distance(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"system_power",50) == 0) {
		listen_system_power(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"input_rc",50) == 0) {
		listen_input_rc(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"mission",50) == 0) {
		listen_mission(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"uavcan_parameter_request",50) == 0) {
		listen_uavcan_parameter_request(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"debug_value",50) == 0) {
		listen_debug_value(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"adc_report",50) == 0) {
		listen_adc_report(num_msgs, topic_instance);
	} else if (strncmp(argv[1],"sensor_correction",50) == 0) {
		listen_sensor_correction(num_msgs, topic_instance);
	} else {
		 printf(" Topic did not match any known topics\n");
	}
	 return 0;
}

void listen_distance_sensor(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(distance_sensor);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(distance_sensor), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: distance_sensor instance %d #%d\n", topic_instance, i);
		distance_sensor_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_ekf2_timestamps(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(ekf2_timestamps);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(ekf2_timestamps), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: ekf2_timestamps instance %d #%d\n", topic_instance, i);
		ekf2_timestamps_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_esc_report(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(esc_report);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(esc_report), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: esc_report instance %d #%d\n", topic_instance, i);
		esc_report_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_sensor_preflight(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(sensor_preflight);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(sensor_preflight), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: sensor_preflight instance %d #%d\n", topic_instance, i);
		sensor_preflight_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_sensor_baro(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(sensor_baro);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(sensor_baro), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: sensor_baro instance %d #%d\n", topic_instance, i);
		sensor_baro_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_control_mode(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(vehicle_control_mode);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(vehicle_control_mode), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: vehicle_control_mode instance %d #%d\n", topic_instance, i);
		vehicle_control_mode_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_tune_control(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(tune_control);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(tune_control), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: tune_control instance %d #%d\n", topic_instance, i);
		tune_control_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_manual_control_setpoint(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(manual_control_setpoint);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(manual_control_setpoint), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: manual_control_setpoint instance %d #%d\n", topic_instance, i);
		manual_control_setpoint_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_air_data(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(vehicle_air_data);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(vehicle_air_data), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: vehicle_air_data instance %d #%d\n", topic_instance, i);
		vehicle_air_data_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_telemetry_status(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(telemetry_status);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(telemetry_status), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: telemetry_status instance %d #%d\n", topic_instance, i);
		telemetry_status_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_actuator_outputs(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(actuator_outputs);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(actuator_outputs), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: actuator_outputs instance %d #%d\n", topic_instance, i);
		actuator_outputs_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_task_stack_info(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(task_stack_info);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(task_stack_info), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: task_stack_info instance %d #%d\n", topic_instance, i);
		task_stack_info_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_collision_report(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(collision_report);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(collision_report), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: collision_report instance %d #%d\n", topic_instance, i);
		collision_report_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_esc_status(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(esc_status);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(esc_status), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: esc_status instance %d #%d\n", topic_instance, i);
		esc_status_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_sensor_accel(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(sensor_accel);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(sensor_accel), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: sensor_accel instance %d #%d\n", topic_instance, i);
		sensor_accel_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_cpuload(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(cpuload);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(cpuload), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: cpuload instance %d #%d\n", topic_instance, i);
		cpuload_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_transponder_report(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(transponder_report);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(transponder_report), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: transponder_report instance %d #%d\n", topic_instance, i);
		transponder_report_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_rates_setpoint(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(vehicle_rates_setpoint);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(vehicle_rates_setpoint), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: vehicle_rates_setpoint instance %d #%d\n", topic_instance, i);
		vehicle_rates_setpoint_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_mc_virtual_rates_setpoint(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(mc_virtual_rates_setpoint);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(mc_virtual_rates_setpoint), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: mc_virtual_rates_setpoint instance %d #%d\n", topic_instance, i);
		vehicle_rates_setpoint_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_fw_virtual_rates_setpoint(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(fw_virtual_rates_setpoint);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(fw_virtual_rates_setpoint), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: fw_virtual_rates_setpoint instance %d #%d\n", topic_instance, i);
		vehicle_rates_setpoint_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_sensor_bias(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(sensor_bias);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(sensor_bias), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: sensor_bias instance %d #%d\n", topic_instance, i);
		sensor_bias_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_debug_vect(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(debug_vect);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(debug_vect), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: debug_vect instance %d #%d\n", topic_instance, i);
		debug_vect_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vtol_vehicle_status(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(vtol_vehicle_status);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(vtol_vehicle_status), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: vtol_vehicle_status instance %d #%d\n", topic_instance, i);
		vtol_vehicle_status_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_test_motor(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(test_motor);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(test_motor), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: test_motor instance %d #%d\n", topic_instance, i);
		test_motor_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_subsystem_info(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(subsystem_info);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(subsystem_info), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: subsystem_info instance %d #%d\n", topic_instance, i);
		subsystem_info_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_wind_estimate(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(wind_estimate);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(wind_estimate), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: wind_estimate instance %d #%d\n", topic_instance, i);
		wind_estimate_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_magnetometer(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(vehicle_magnetometer);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(vehicle_magnetometer), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: vehicle_magnetometer instance %d #%d\n", topic_instance, i);
		vehicle_magnetometer_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_follow_target(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(follow_target);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(follow_target), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: follow_target instance %d #%d\n", topic_instance, i);
		follow_target_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_airspeed(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(airspeed);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(airspeed), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: airspeed instance %d #%d\n", topic_instance, i);
		airspeed_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_roi(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(vehicle_roi);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(vehicle_roi), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: vehicle_roi instance %d #%d\n", topic_instance, i);
		vehicle_roi_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_pwm_input(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(pwm_input);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(pwm_input), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: pwm_input instance %d #%d\n", topic_instance, i);
		pwm_input_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_command_ack(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(vehicle_command_ack);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(vehicle_command_ack), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: vehicle_command_ack instance %d #%d\n", topic_instance, i);
		vehicle_command_ack_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_differential_pressure(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(differential_pressure);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(differential_pressure), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: differential_pressure instance %d #%d\n", topic_instance, i);
		differential_pressure_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_geofence_result(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(geofence_result);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(geofence_result), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: geofence_result instance %d #%d\n", topic_instance, i);
		geofence_result_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_ekf2_innovations(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(ekf2_innovations);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(ekf2_innovations), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: ekf2_innovations instance %d #%d\n", topic_instance, i);
		ekf2_innovations_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_fw_pos_ctrl_status(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(fw_pos_ctrl_status);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(fw_pos_ctrl_status), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: fw_pos_ctrl_status instance %d #%d\n", topic_instance, i);
		fw_pos_ctrl_status_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_global_position(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(vehicle_global_position);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(vehicle_global_position), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: vehicle_global_position instance %d #%d\n", topic_instance, i);
		vehicle_global_position_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_global_position_groundtruth(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(vehicle_global_position_groundtruth);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(vehicle_global_position_groundtruth), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: vehicle_global_position_groundtruth instance %d #%d\n", topic_instance, i);
		vehicle_global_position_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_optical_flow(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(optical_flow);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(optical_flow), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: optical_flow instance %d #%d\n", topic_instance, i);
		optical_flow_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_parameter_update(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(parameter_update);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(parameter_update), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: parameter_update instance %d #%d\n", topic_instance, i);
		parameter_update_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_position_setpoint_triplet(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(position_setpoint_triplet);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(position_setpoint_triplet), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: position_setpoint_triplet instance %d #%d\n", topic_instance, i);
		position_setpoint_triplet_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_actuator_controls(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(actuator_controls);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(actuator_controls), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: actuator_controls instance %d #%d\n", topic_instance, i);
		actuator_controls_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_actuator_controls_0(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(actuator_controls_0);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(actuator_controls_0), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: actuator_controls_0 instance %d #%d\n", topic_instance, i);
		actuator_controls_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_actuator_controls_1(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(actuator_controls_1);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(actuator_controls_1), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: actuator_controls_1 instance %d #%d\n", topic_instance, i);
		actuator_controls_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_actuator_controls_2(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(actuator_controls_2);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(actuator_controls_2), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: actuator_controls_2 instance %d #%d\n", topic_instance, i);
		actuator_controls_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_actuator_controls_3(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(actuator_controls_3);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(actuator_controls_3), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: actuator_controls_3 instance %d #%d\n", topic_instance, i);
		actuator_controls_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_actuator_controls_virtual_fw(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(actuator_controls_virtual_fw);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(actuator_controls_virtual_fw), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: actuator_controls_virtual_fw instance %d #%d\n", topic_instance, i);
		actuator_controls_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_actuator_controls_virtual_mc(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(actuator_controls_virtual_mc);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(actuator_controls_virtual_mc), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: actuator_controls_virtual_mc instance %d #%d\n", topic_instance, i);
		actuator_controls_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_position_setpoint(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(position_setpoint);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(position_setpoint), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: position_setpoint instance %d #%d\n", topic_instance, i);
		position_setpoint_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_actuator_direct(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(actuator_direct);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(actuator_direct), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: actuator_direct instance %d #%d\n", topic_instance, i);
		actuator_direct_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_home_position(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(home_position);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(home_position), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: home_position instance %d #%d\n", topic_instance, i);
		home_position_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_tecs_status(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(tecs_status);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(tecs_status), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: tecs_status instance %d #%d\n", topic_instance, i);
		tecs_status_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_debug_key_value(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(debug_key_value);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(debug_key_value), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: debug_key_value instance %d #%d\n", topic_instance, i);
		debug_key_value_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_land_detected(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(vehicle_land_detected);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(vehicle_land_detected), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: vehicle_land_detected instance %d #%d\n", topic_instance, i);
		vehicle_land_detected_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_mount_orientation(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(mount_orientation);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(mount_orientation), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: mount_orientation instance %d #%d\n", topic_instance, i);
		mount_orientation_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_mavlink_log(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(mavlink_log);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(mavlink_log), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: mavlink_log instance %d #%d\n", topic_instance, i);
		mavlink_log_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_status(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(vehicle_status);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(vehicle_status), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: vehicle_status instance %d #%d\n", topic_instance, i);
		vehicle_status_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_attitude(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(vehicle_attitude);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(vehicle_attitude), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: vehicle_attitude instance %d #%d\n", topic_instance, i);
		vehicle_attitude_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_attitude_groundtruth(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(vehicle_attitude_groundtruth);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(vehicle_attitude_groundtruth), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: vehicle_attitude_groundtruth instance %d #%d\n", topic_instance, i);
		vehicle_attitude_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_vision_attitude(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(vehicle_vision_attitude);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(vehicle_vision_attitude), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: vehicle_vision_attitude instance %d #%d\n", topic_instance, i);
		vehicle_attitude_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_mission_result(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(mission_result);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(mission_result), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: mission_result instance %d #%d\n", topic_instance, i);
		mission_result_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_battery_status(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(battery_status);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(battery_status), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: battery_status instance %d #%d\n", topic_instance, i);
		battery_status_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_camera_trigger(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(camera_trigger);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(camera_trigger), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: camera_trigger instance %d #%d\n", topic_instance, i);
		camera_trigger_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_rc_parameter_map(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(rc_parameter_map);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(rc_parameter_map), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: rc_parameter_map instance %d #%d\n", topic_instance, i);
		rc_parameter_map_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_satellite_info(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(satellite_info);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(satellite_info), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: satellite_info instance %d #%d\n", topic_instance, i);
		satellite_info_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_landing_target_innovations(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(landing_target_innovations);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(landing_target_innovations), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: landing_target_innovations instance %d #%d\n", topic_instance, i);
		landing_target_innovations_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_landing_target_pose(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(landing_target_pose);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(landing_target_pose), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: landing_target_pose instance %d #%d\n", topic_instance, i);
		landing_target_pose_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_local_position_setpoint(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(vehicle_local_position_setpoint);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(vehicle_local_position_setpoint), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: vehicle_local_position_setpoint instance %d #%d\n", topic_instance, i);
		vehicle_local_position_setpoint_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_commander_state(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(commander_state);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(commander_state), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: commander_state instance %d #%d\n", topic_instance, i);
		commander_state_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_sensor_mag(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(sensor_mag);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(sensor_mag), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: sensor_mag instance %d #%d\n", topic_instance, i);
		sensor_mag_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_rc_channels(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(rc_channels);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(rc_channels), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: rc_channels instance %d #%d\n", topic_instance, i);
		rc_channels_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_att_pos_mocap(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(att_pos_mocap);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(att_pos_mocap), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: att_pos_mocap instance %d #%d\n", topic_instance, i);
		att_pos_mocap_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_sensor_combined(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(sensor_combined);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(sensor_combined), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: sensor_combined instance %d #%d\n", topic_instance, i);
		sensor_combined_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_camera_capture(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(camera_capture);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(camera_capture), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: camera_capture instance %d #%d\n", topic_instance, i);
		camera_capture_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_estimator_status(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(estimator_status);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(estimator_status), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: estimator_status instance %d #%d\n", topic_instance, i);
		estimator_status_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_uavcan_parameter_value(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(uavcan_parameter_value);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(uavcan_parameter_value), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: uavcan_parameter_value instance %d #%d\n", topic_instance, i);
		uavcan_parameter_value_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_command(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(vehicle_command);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(vehicle_command), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: vehicle_command instance %d #%d\n", topic_instance, i);
		vehicle_command_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_status_flags(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(vehicle_status_flags);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(vehicle_status_flags), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: vehicle_status_flags instance %d #%d\n", topic_instance, i);
		vehicle_status_flags_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_led_control(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(led_control);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(led_control), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: led_control instance %d #%d\n", topic_instance, i);
		led_control_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_time_offset(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(time_offset);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(time_offset), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: time_offset instance %d #%d\n", topic_instance, i);
		time_offset_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_attitude_setpoint(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(vehicle_attitude_setpoint);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(vehicle_attitude_setpoint), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: vehicle_attitude_setpoint instance %d #%d\n", topic_instance, i);
		vehicle_attitude_setpoint_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_mc_virtual_attitude_setpoint(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(mc_virtual_attitude_setpoint);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(mc_virtual_attitude_setpoint), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: mc_virtual_attitude_setpoint instance %d #%d\n", topic_instance, i);
		vehicle_attitude_setpoint_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_fw_virtual_attitude_setpoint(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(fw_virtual_attitude_setpoint);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(fw_virtual_attitude_setpoint), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: fw_virtual_attitude_setpoint instance %d #%d\n", topic_instance, i);
		vehicle_attitude_setpoint_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_multirotor_motor_limits(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(multirotor_motor_limits);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(multirotor_motor_limits), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: multirotor_motor_limits instance %d #%d\n", topic_instance, i);
		multirotor_motor_limits_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_local_position(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(vehicle_local_position);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(vehicle_local_position), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: vehicle_local_position instance %d #%d\n", topic_instance, i);
		vehicle_local_position_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_local_position_groundtruth(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(vehicle_local_position_groundtruth);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(vehicle_local_position_groundtruth), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: vehicle_local_position_groundtruth instance %d #%d\n", topic_instance, i);
		vehicle_local_position_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_vision_position(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(vehicle_vision_position);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(vehicle_vision_position), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: vehicle_vision_position instance %d #%d\n", topic_instance, i);
		vehicle_local_position_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_servorail_status(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(servorail_status);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(servorail_status), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: servorail_status instance %d #%d\n", topic_instance, i);
		servorail_status_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_actuator_armed(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(actuator_armed);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(actuator_armed), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: actuator_armed instance %d #%d\n", topic_instance, i);
		actuator_armed_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_sensor_gyro(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(sensor_gyro);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(sensor_gyro), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: sensor_gyro instance %d #%d\n", topic_instance, i);
		sensor_gyro_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_irlock_report(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(irlock_report);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(irlock_report), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: irlock_report instance %d #%d\n", topic_instance, i);
		irlock_report_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_vehicle_gps_position(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(vehicle_gps_position);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(vehicle_gps_position), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: vehicle_gps_position instance %d #%d\n", topic_instance, i);
		vehicle_gps_position_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_offboard_control_mode(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(offboard_control_mode);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(offboard_control_mode), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: offboard_control_mode instance %d #%d\n", topic_instance, i);
		offboard_control_mode_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_rate_ctrl_status(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(rate_ctrl_status);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(rate_ctrl_status), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: rate_ctrl_status instance %d #%d\n", topic_instance, i);
		rate_ctrl_status_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_safety(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(safety);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(safety), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: safety instance %d #%d\n", topic_instance, i);
		safety_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_sensor_selection(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(sensor_selection);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(sensor_selection), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: sensor_selection instance %d #%d\n", topic_instance, i);
		sensor_selection_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_log_message(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(log_message);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(log_message), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: log_message instance %d #%d\n", topic_instance, i);
		log_message_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_power_button_state(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(power_button_state);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(power_button_state), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: power_button_state instance %d #%d\n", topic_instance, i);
		power_button_state_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_obstacle_distance(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(obstacle_distance);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(obstacle_distance), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: obstacle_distance instance %d #%d\n", topic_instance, i);
		obstacle_distance_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_system_power(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(system_power);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(system_power), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: system_power instance %d #%d\n", topic_instance, i);
		system_power_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_input_rc(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(input_rc);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(input_rc), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: input_rc instance %d #%d\n", topic_instance, i);
		input_rc_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_mission(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(mission);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(mission), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: mission instance %d #%d\n", topic_instance, i);
		mission_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_uavcan_parameter_request(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(uavcan_parameter_request);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(uavcan_parameter_request), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: uavcan_parameter_request instance %d #%d\n", topic_instance, i);
		uavcan_parameter_request_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_debug_value(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(debug_value);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(debug_value), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: debug_value instance %d #%d\n", topic_instance, i);
		debug_value_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_adc_report(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(adc_report);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(adc_report), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: adc_report instance %d #%d\n", topic_instance, i);
		adc_report_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

void listen_sensor_correction(unsigned num_msgs, unsigned topic_instance) {
	orb_id_t ID = ORB_ID(sensor_correction);
	if (orb_exists(ID, topic_instance) != 0) { printf("never published\n"); return; }
	int sub = orb_subscribe_multi(ORB_ID(sensor_correction), topic_instance);
	bool updated = false;
	unsigned i = 0;
	hrt_abstime start_time = hrt_absolute_time();
	while(i < num_msgs) {
		orb_check(sub, &updated);
		if (i == 0) { updated = true; } else { usleep(500); }
		if (updated) {
			start_time = hrt_absolute_time();
			i++;
		printf("\nTOPIC: sensor_correction instance %d #%d\n", topic_instance, i);
		sensor_correction_s container = {};
		orb_copy(ID, sub, &container);
		print_message(container);
		} else {
			if (check_timeout(start_time)) {
				break;
			}
		}
	}
	orb_unsubscribe(sub);
}

